# 编译原理课程设计实验报告

## 1. 实验目的

1. 深入理解编译原理中的词法分析和语法分析理论
2. 掌握正则表达式到有限自动机的转换方法
3. 实现从正则表达式到词法分析器的自动生成
4. 掌握多种语法分析方法（LL(1)、LR(0)、SLR(1)、LR(1)）
5. 实现从BNF文法到语法分析器的自动生成
6. 培养综合运用面向对象编程和编译原理知识的能力
7. 学习使用Qt框架进行图形化界面开发

## 2. 实验环境

| 环境项 | 具体配置 |
|--------|----------|
| 操作系统 | Windows 10/11 |
| 开发框架 | Qt 6.x |
| 编译器 | MinGW 8.x/9.x |
| 开发工具 | Qt Creator 11.x / VSCode |
| 项目构建工具 | qmake |
| 编程语言 | C++ |

## 3. 实验原理

### 3.1 词法分析原理

词法分析是编译过程的第一阶段，主要任务是将源程序分解为一系列具有独立意义的词法单元（Token）。本实验采用正则表达式作为词法规则的描述工具，并通过以下步骤实现词法分析器的自动生成：

1. **正则表达式解析**：将输入的正则表达式转换为抽象语法树（AST）
2. **NFA构建**：使用Thompson构造法将AST转换为非确定有限自动机（NFA）
3. **DFA构建**：使用子集构造法将NFA转换为确定有限自动机（DFA）
4. **DFA最小化**：使用Hopcroft算法对DFA进行最小化，减少状态数量
5. **词法分析器生成**：根据最小化DFA生成词法分析器代码

### 3.2 语法分析原理

语法分析是编译过程的第二阶段，主要任务是根据文法规则检查词法单元序列是否符合语法，并构建语法树。本实验支持多种语法分析方法：

#### 3.2.1 LL(1)分析

LL(1)分析是一种自顶向下的语法分析方法，使用预测分析表进行分析。主要步骤包括：
1. 计算FIRST集和FOLLOW集
2. 构建LL(1)预测分析表
3. 使用栈和分析表进行语法分析

#### 3.2.2 LR系列分析

LR系列分析是自底向上的语法分析方法，包括LR(0)、SLR(1)和LR(1)三种变体：

- **LR(0)分析**：使用LR(0)项目集和分析表，不考虑前瞻符号
- **SLR(1)分析**：在LR(0)基础上，使用FOLLOW集解决冲突
- **LR(1)分析**：使用带前瞻符号的项目集，具有更强的表达能力

## 4. 实验步骤

### 4.1 项目构建

1. **使用Qt Creator构建**
   - 打开`byylCD.pro`文件
   - 选择合适的构建套件
   - 点击构建按钮编译项目
   - 点击运行按钮启动程序

2. **使用命令行构建**
   ```
   qmake
   mingw32-make
   ```

### 4.2 词法分析器生成

1. **正则表达式输入**
   - 在"正则表达式"标签页中输入正则表达式
   - 支持多行输入，每行一个正则表达式
   - 支持注释行（以`//`开头）
   - 支持正则表达式引用

2. **解析正则表达式**
   - 点击"解析正则表达式"按钮
   - 系统将解析输入的正则表达式
   - 显示解析结果

3. **生成NFA**
   - 点击"生成NFA"按钮
   - 系统将为每个正则表达式生成对应的NFA
   - 在"NFA"标签页中查看NFA状态转移表
   - 使用组合框切换查看总NFA图或各独立NFA图

4. **生成DFA**
   - 点击"生成DFA"按钮
   - 系统将NFA转换为DFA
   - 在"DFA"标签页中查看DFA状态转移表
   - 使用组合框切换查看总DFA图或各独立DFA图

5. **最小化DFA**
   - 点击"最小化DFA"按钮
   - 系统将最小化DFA
   - 在"最小化DFA"标签页中查看最小化DFA状态转移表
   - 使用组合框切换查看总最小化DFA图或各独立最小化DFA图

6. **生成词法分析器**
   - 点击"生成词法分析器"按钮
   - 系统将生成词法分析器代码
   - 点击"保存为.cpp"按钮保存代码

7. **测试词法分析器**
   - 在"测试"标签页中输入测试文本
   - 点击"运行词法分析"按钮
   - 查看词法分析结果

### 4.3 语法分析器生成

1. **BNF文法输入**
   - 在"文法输入"标签页中输入BNF文法
   - 支持多行输入，每行一个产生式
   - 支持注释行（以`//`开头）

2. **解析BNF文法**
   - 点击"解析文法"按钮
   - 系统将解析输入的BNF文法
   - 显示解析结果，包括非终结符、终结符、产生式等

3. **生成分析表**
   - 选择分析方法（LL(1)、LR(0)、SLR(1)、LR(1)）
   - 点击"生成分析表"按钮
   - 系统将生成相应的分析表
   - 支持查看分析表内容

4. **语法分析**
   - 在"词法分析结果"标签页中输入词法分析结果
   - 点击"开始分析"按钮
   - 系统将进行语法分析
   - 支持查看分析步骤和语法树

## 5. 代码实现分析

### 5.1 词法分析器核心实现

#### 5.1.1 正则表达式引擎（RegexEngine）

正则表达式引擎是词法分析的核心组件，负责将正则表达式转换为NFA。其主要功能包括：

- **词法分析**：将正则表达式字符串转换为令牌列表
- **语法分析**：将令牌列表转换为抽象语法树
- **NFA构建**：根据AST构建NFA

核心代码位于`src/task1/regexengine.cpp`，其中`compile`方法是主要入口：

```cpp
bool RegexEngine::compile(const QString &pattern) {
    // 清理之前的编译结果
    // 词法分析：将正则表达式字符串转换为令牌列表
    QList<Token> tokens = lex(pattern);
    // 语法分析：将令牌列表转换为抽象语法树
    m_root = parse(tokens);
    // 构建NFA：根据抽象语法树构建非确定有限自动机
    m_nfa = buildNFA(m_root);
    return true;
}
```

#### 5.1.2 NFA到DFA转换（DFABuilder）

DFABuilder类负责将NFA转换为DFA，使用子集构造法实现。核心算法是计算ε-闭包和状态转移：

```cpp
DFA DFABuilder::convertNFAtoDFA(const NFA &nfa) {
    // 初始化DFA
    DFA dfa;
    // 计算初始状态的ε-闭包
    QSet<NFAState> initialClosure = epsilonClosure(nfa, {nfa.startState});
    // 使用队列处理所有状态
    QQueue<DFAStateInfo> queue;
    // 构建状态转移表
    // 返回构建好的DFA
    return dfa;
}
```

#### 5.1.3 DFA最小化（DFAMinimizer）

DFAMinimizer类负责使用Hopcroft算法对DFA进行最小化，减少状态数量：

```cpp
DFA DFAMinimizer::minimizeDFA(const DFA &dfa) {
    // 初始化划分
    // 迭代划分状态集
    // 构建最小化DFA
    // 返回最小化后的DFA
    return minimizedDfa;
}
```

### 5.2 语法分析器核心实现

#### 5.2.1 LR1分析器（LR1Parser）

LR1Parser类是语法分析的核心组件，负责执行LR1语法分析。其主要功能包括：

- **动作表查找**：根据当前状态和输入符号查找对应动作
- **移进-归约分析**：执行移进、归约、接受等动作
- **语法树构建**：根据分析过程构建语法树
- **语义树构建**：生成语义抽象语法树

核心代码位于`src/task2/LR1Parser.cpp`，其中`parse`方法是主要入口：

```cpp
ParseResult LR1Parser::parse(const QVector<TokenInfo>& tokens, const Grammar& g, const LR1ActionTable& t) {
    // 初始化分析栈和输入
    // 主分析循环
    while (!input.isEmpty()) {
        // 获取当前动作
        QString act = actionFor(t, st, a);
        // 处理动作
        if (act == "acc") {
            // 接受，分析成功
        } else if (act.startsWith("s")) {
            // 移进动作
        } else if (act.startsWith("r")) {
            // 归约动作
        }
    }
    return res;
}
```

## 6. 实验结果与数据

### 6.1 词法分析器测试结果

使用`test/regix_sample.txt`作为测试用例，包含以下正则表达式：

```
letter=[A-Za-z]
digit=[0-9]
_identifier100=letter(letter|digit)*
_number101=digit+
_comment102={((digit|\+|-|\*|/|%|\^|<|<>|<=|>=|>|=|$|;|:=|letter)*)}
_special103S=\+|-|\*|/|%|\^|<|<>|<=|>=|>|=|:=|;
_Keyword200S=(i|I)(f|F)|(t|T)(h|H)(e|E)(n|N)|(e|E)(l|L)(s|S)(e|E)|(E|e)(n|N)(D|d)|(r|R)(e|E)(p|P)(e|E)(a|A)(t|T)|(u|U)(n|N)(t|T)(I|i)(l|L)|(r|R)(e|E)(a|A)(D|d)|(w|W)(r|R)(i|I)(t|T)(E|e)
```

#### 6.1.1 NFA生成结果

- 总状态数：127
- 总转换数：189
- 接受状态数：7

#### 6.1.2 DFA生成结果

- 总状态数：58
- 总转换数：184
- 接受状态数：7

#### 6.1.3 最小化DFA结果

- 总状态数：42
- 总转换数：136
- 接受状态数：7

### 6.2 语法分析器测试结果

使用Tiny语言的语法规则作为测试用例，包含以下产生式：

```
program -> block.
block -> declarations statements
declarations -> declaration declarations | ε
declaration -> var identifierlist : type ;
identifierlist -> identifier , identifierlist | identifier
statements -> statement statements | ε
statement -> assignstatement | ifstatement | whilestatement | readstatement | writestatement
assignstatement -> identifier := expression ;
ifstatement -> if condition then statements else statements end
whilestatement -> while condition do statements end
readstatement -> read identifier ;
writestatement -> write expression ;
condition -> expression = expression | expression < expression
```

#### 6.2.1 LL(1)分析结果

- 非终结符数量：12
- 终结符数量：18
- 产生式数量：16
- 预测分析表大小：12×18=216

#### 6.2.2 LR1分析结果

- 项目集数量：32
- 动作表条目数：187
- Goto表条目数：110
- 无冲突产生

## 7. 问题分析与解决方案

### 7.1 问题1：正则表达式解析错误处理

**问题描述**：当输入无效的正则表达式时，系统无法提供详细的错误信息，导致用户难以调试。

**解决方案**：在词法分析和语法分析过程中添加详细的错误检查和信息输出，包括：
- 记录错误位置
- 提供具体的错误原因
- 显示期望的令牌或符号

```cpp
// 语法分析中的错误处理示例
if (pos < tokens.size() && tokens[pos].type == TokenType::CARET_NEGATE) {
    isNegated = true;
    pos++;
} else {
    throw QString("语法错误：字符集内不允许的符号");
}
```

### 7.2 问题2：LR1分析表构建效率

**问题描述**：LR1分析表构建过程中，项目集数量可能呈指数级增长，导致构建时间过长。

**解决方案**：
- 优化项目集合并算法
- 使用哈希表存储项目集，提高查找效率
- 实现增量构建，只处理必要的项目集

### 7.3 问题3：语法错误恢复

**问题描述**：当输入存在语法错误时，分析器立即终止，无法提供更多错误信息。

**解决方案**：
- 实现简单的错误恢复机制，如跳过当前符号继续分析
- 记录多个错误位置和信息
- 提供错误修复建议

```cpp
// 错误恢复示例
if (act.isEmpty()) {
    // 错误触发点后移：若上一步为移进，则用当前lookahead的下一符号重试一次
    if (!res.steps.isEmpty() && res.steps.back().action.startsWith("s") && input.size() > 1) {
        QString a2 = input[1].tokenType;
        QString act2 = actionFor(t, st, a2);
        if (!act2.isEmpty())
            act = act2;
    }
}
```

## 8. 实验总结与展望

### 8.1 实验总结

本次实验成功实现了一个基于Qt框架的词法与语法分析器生成器，主要完成了以下工作：

1. **词法分析器生成**：实现了从正则表达式到NFA、DFA、最小化DFA的完整转换流程，并能生成词法分析器代码

2. **语法分析器生成**：支持LL(1)、LR(0)、SLR(1)、LR(1)多种语法分析方法，能够根据BNF文法生成相应的分析表和语法树

3. **图形化界面**：使用Qt框架开发了直观的图形化界面，方便用户输入正则表达式和文法、查看分析结果和图形化表示

4. **测试验证**：使用多种测试用例验证了系统的正确性和稳定性，包括Tiny语言和mini-c语言的词法和语法规则

### 8.2 实验展望

虽然本次实验已经实现了词法与语法分析器生成器的基本功能，但仍有一些可以改进和扩展的方向：

1. **性能优化**：进一步优化DFA最小化算法和LR1分析表构建算法，提高系统处理大规模规则的能力

2. **错误处理增强**：实现更强大的错误恢复机制，提供更详细的错误信息和修复建议

3. **语义分析支持**：扩展系统，添加语义分析功能，如类型检查、符号表管理等

4. **代码生成**：实现中间代码生成和目标代码生成，完成完整的编译器前端

5. **更多语言支持**：扩展支持更多编程语言的词法和语法规则

6. **可视化增强**：改进有限自动机和语法树的可视化表示，提供更直观的图形化展示

通过本次实验，我们深入理解了编译原理中的核心概念和算法，并掌握了如何将这些理论知识应用到实际的编译器开发中。这为我们后续学习编译原理的高级内容和从事编译器相关工作打下了坚实的基础。

## 9. 参考文献

1. 陈火旺等. 编译原理（第3版）. 国防工业出版社, 2010
2. Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman. 编译原理：原理、技术与工具（第2版）. 机械工业出版社, 2009
3. 王生原, 董渊, 张素琴. 编译原理（第3版）. 清华大学出版社, 2015
4. Qt官方文档：https://doc.qt.io/
5. 正则表达式教程：https://regexr.com/