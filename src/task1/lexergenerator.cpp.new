QString LexerGenerator::generateTokenMap(const QList<RegexItem> &regexItems)
{
    QString mapContent;
    
    // 添加文件头注释
    mapContent += "// Token映射文件，生成自词法分析器生成器\n";
    mapContent += "// 格式：编码=终结符名称\n\n";
    
    // 为每个正则表达式项生成映射
    for (const RegexItem &item : regexItems) {
        if (item.isMultiWord) {
            // 多单词情况（关键字、符号等）
            int currentCode = item.code;
            
            // 使用QMap来确保同一单词的不同大小写形式映射到同一个编码
            QMap<QString, int> lowercaseToCodeMap;
            
            for (const QString &word : item.wordList) {
                QString lowercaseWord = word.toLower();
                if (!lowercaseToCodeMap.contains(lowercaseWord)) {
                    lowercaseToCodeMap[lowercaseWord] = currentCode++;
                }
            }
            
            // 生成映射条目
            for (auto it = lowercaseToCodeMap.constBegin(); it != lowercaseToCodeMap.constEnd(); ++it) {
                // 修复转义字符，只保留必要的转义
                QString tokenValue = it.key();
                // 去除多余的转义字符
                tokenValue.replace("\\", "");
                mapContent += QString("%1=%2\n").arg(it.value()).arg(tokenValue);
            }
        } else {
            // 单单词情况（标识符、数字等）
            QString tokenName = item.name.mid(1); // 移除下划线前缀
            
            // 提取纯名称，去除后面的编号
            QString pureTokenName;
            for (QChar c : tokenName) {
                if (!c.isDigit()) {
                    pureTokenName.append(c);
                } else {
                    break;
                }
            }
            
            mapContent += QString("%1=%2\n").arg(item.code).arg(pureTokenName);
        }
    }
    
    return mapContent;
}