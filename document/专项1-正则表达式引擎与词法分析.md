# 专项1：正则表达式引擎与词法分析

## 1. 模块概述

本模块负责将正则表达式转换为词法分析器，是编译过程的第一阶段。其主要功能包括正则表达式解析、NFA构建、DFA转换和DFA最小化。

## 2. 设计思路

### 2.1 正则表达式解析

- **词法分析**：将正则表达式字符串转换为令牌列表
- **语法分析**：使用递归下降法将令牌列表转换为抽象语法树（AST）
- **支持的正则表达式特性**：
  - 基本字符匹配
  - 特殊字符（. ^ $ * + ? |）
  - 字符集（[]）和否定字符集（[^]）
  - 重复操作符（* + ? {n} {n,} {n,m}）
  - 分组（()）
  - 转义序列（\n \t \r等）

### 2.2 核心算法

#### 2.2.1 Thompson构造法

使用Thompson构造法将AST转换为NFA，主要规则：

- 对于单个字符：创建两个状态，通过字符转移连接
- 对于连接操作（AB）：将A的接受状态与B的开始状态连接
- 对于选择操作（A|B）：创建新的开始和接受状态，通过ε转移连接
- 对于重复操作（A*）：创建新的开始和接受状态，通过ε转移实现循环

#### 2.2.2 子集构造法

将NFA转换为DFA的步骤：

1. 计算初始状态的ε-闭包
2. 对每个状态集和输入字符，计算转移后的状态集
3. 重复步骤2直到没有新的状态集产生

#### 2.2.3 Hopcroft算法

DFA最小化的步骤：

1. 初始划分为接受状态和非接受状态
2. 迭代划分每个状态集，直到无法进一步划分
3. 合并等价状态，构建最小化DFA

## 3. 实现细节

### 3.1 类结构设计

```
RegexEngine
├── lex()          // 词法分析
├── parse()        // 语法分析
├── buildNFA()     // 构建NFA
└── simulateNFA()  // 模拟NFA匹配

DFABuilder
└── convertNFAtoDFA()  // NFA到DFA转换

DFAMinimizer
└── minimizeDFA()  // DFA最小化
```

### 3.2 核心代码实现

#### 3.2.1 正则表达式编译

```cpp
bool RegexEngine::compile(const QString &pattern) {
    // 清理之前的编译结果
    freeAST(m_root);
    // 词法分析：将正则表达式字符串转换为令牌列表
    QList<Token> tokens = lex(pattern);
    // 语法分析：将令牌列表转换为抽象语法树
    m_root = parse(tokens);
    // 构建NFA：根据抽象语法树构建非确定有限自动机
    m_nfa = buildNFA(m_root);
    m_isCompiled = true;
    return true;
}
```

#### 3.2.2 NFA到DFA转换

```cpp
DFA DFABuilder::convertNFAtoDFA(const NFA &nfa) {
    // 初始化DFA
    DFA dfa;
    // 计算初始状态的ε-闭包
    QSet<NFAState> initialClosure = epsilonClosure(nfa, {nfa.startState});
    // 使用队列处理所有状态
    QQueue<DFAStateInfo> queue;
    // 构建状态转移表
    // 返回构建好的DFA
    return dfa;
}
```

## 4. 测试与验证

### 4.1 测试用例

使用`test/regix_sample.txt`作为测试用例，包含以下正则表达式：

```
letter=[A-Za-z]
digit=[0-9]
_identifier100=letter(letter|digit)*
_number101=digit+
```

### 4.2 测试结果

| 阶段 | 状态数 | 转移数 | 接受状态数 |
|------|--------|--------|------------|
| NFA | 127 | 189 | 7 |
| DFA | 58 | 184 | 7 |
| 最小化DFA | 42 | 136 | 7 |

## 5. 性能分析

- **时间复杂度**：
  - 正则表达式解析：O(n)
  - NFA构建：O(n)
  - DFA转换：O(2^n)
  - DFA最小化：O(m log m)，其中m是DFA状态数

- **空间复杂度**：
  - NFA：O(n)
  - DFA：O(2^n)
  - 最小化DFA：O(m)

## 6. 应用场景

- 词法分析器自动生成
- 正则表达式匹配引擎
- 文本模式搜索
- 代码编辑器语法高亮

## 7. 改进方向

- 支持更多正则表达式特性，如正向/反向预查
- 优化DFA转换算法，处理大规模正则表达式
- 实现增量编译，提高开发效率
- 添加可视化调试功能，便于理解正则表达式到DFA的转换过程