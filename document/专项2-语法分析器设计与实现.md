# 专项2：语法分析器设计与实现

## 1. 模块概述

语法分析器是编译过程的第二阶段，负责根据文法规则检查词法单元序列是否符合语法，并构建语法树。本模块支持多种语法分析方法，包括LL(1)、LR(0)、SLR(1)和LR(1)。

## 2. 设计思路

### 2.1 BNF文法解析

- **功能**：将输入的BNF文法转换为内部表示
- **支持的文法格式**：
  ```
  nonterminal -> production1 | production2 | ...
  ```
- **处理流程**：
  1. 词法分析：将文法字符串转换为令牌列表
  2. 语法分析：解析令牌列表，构建产生式规则
  3. 构建非终结符和终结符集合
  4. 确定开始符号

### 2.2 LL(1)分析器

- **功能**：生成LL(1)预测分析表，执行LL(1)语法分析
- **核心步骤**：
  1. 计算FIRST集
  2. 计算FOLLOW集
  3. 构建LL(1)预测分析表
  4. 使用栈和分析表进行语法分析

### 2.3 LR系列分析器

#### 2.3.1 LR(0)分析器

- **功能**：生成LR(0)分析表，执行LR(0)语法分析
- **核心步骤**：
  1. 扩展文法（添加开始符号）
  2. 构建LR(0)项目集规范族
  3. 构建动作表和Goto表
  4. 执行移进-归约分析

#### 2.3.2 SLR(1)分析器

- **功能**：生成SLR(1)分析表，执行SLR(1)语法分析
- **核心步骤**：
  1. 计算FOLLOW集
  2. 在LR(0)基础上，使用FOLLOW集解决冲突
  3. 构建动作表和Goto表
  4. 执行移进-归约分析

#### 2.3.3 LR(1)分析器

- **功能**：生成LR(1)分析表，执行LR(1)语法分析
- **核心步骤**：
  1. 构建LR(1)项目集规范族
  2. 构建动作表和Goto表
  3. 执行移进-归约分析
  4. 支持冲突策略和优先移进终结符配置

## 3. 实现细节

### 3.1 类结构设计

```
GrammarParser
└── parseGrammar()  // 解析BNF文法

LL1
├── computeFirstSets()  // 计算FIRST集
├── computeFollowSets()  // 计算FOLLOW集
├── buildParseTable()  // 构建LL(1)预测分析表
└── parse()  // 执行LL(1)分析

LR0
├── buildLR0Items()  // 构建LR(0)项目集
└── buildLR0Table()  // 构建LR(0)分析表

SLR
└── buildSLRTable()  // 构建SLR(1)分析表

LR1
├── buildLR1Items()  // 构建LR(1)项目集
└── buildLR1Table()  // 构建LR(1)分析表

LR1Parser
├── parse()  // 执行LR1语法分析
└── parseWithSemantics()  // 带语义动作的LR1分析
```

### 3.2 核心代码实现

#### 3.2.1 LR1分析器主循环

```cpp
ParseResult LR1Parser::parse(const QVector<TokenInfo>& tokens, const Grammar& g, const LR1ActionTable& t) {
    // 初始化分析栈和输入
    QVector<TokenInfo> input = tokens;
    TokenInfo eofToken; eofToken.tokenType = "$"; input.push_back(eofToken);
    QVector<QPair<int, QString>> stack; stack.push_back({0, QString()});
    
    // 主分析循环
    while (!input.isEmpty()) {
        QString a = input[0].tokenType; // 当前输入符号
        int st = stack.back().first; // 当前状态
        QString act = actionFor(t, st, a); // 获取动作
        
        if (act == "acc") {
            // 接受，分析成功
            break;
        } else if (act.startsWith("s")) {
            // 移进动作
            int to = act.mid(1).toInt();
            stack.push_back({to, a});
            input.pop_front();
        } else if (act.startsWith("r")) {
            // 归约动作
            QString L; QVector<QString> rhs;
            if (parseReduction(t, act, L, rhs)) {
                // 执行归约
                int k = rhs.size();
                for (int i = 0; i < k; ++i) stack.pop_back();
                int stTop = stack.back().first;
                int gotoState = gotoFor(t, stTop, L);
                stack.push_back({gotoState, L});
            }
        }
    }
    return res;
}
```

#### 3.2.2 语义AST构建

```cpp
static SemanticASTNode* buildSemantic(const QString& L, const QVector<SemanticASTNode*>& semKids, 
                                      const QVector<int>& roles, const QMap<int, QString>& roleMeaning) {
    SemanticASTNode* root = nullptr;
    SemanticASTNode* currentRoot = nullptr;
    
    // 遍历所有子树和对应的角色
    for (int i = 0; i < semKids.size(); ++i) {
        SemanticASTNode* child = semKids[i];
        int role = (i < roles.size()) ? roles[i] : 0;
        QString roleName = roleMeaning.value(role, "skip");
        
        if (roleName == "root") {
            // 规则2: 1=提升为根节点
            if (!root) {
                root = child;
                currentRoot = child;
            } else {
                root->children.push_back(child);
                currentRoot = child;
            }
        } else if (roleName == "child") {
            // 规则3: 2=作为最近的角色1节点的子节点
            if (currentRoot) {
                currentRoot->children.push_back(child);
            } else if (root) {
                root->children.push_back(child);
            }
        }
    }
    
    // 如果没有找到任何节点，创建一个默认根节点
    if (!root) {
        root = makeSemNode(L);
    }
    
    return root;
}
```

## 4. 冲突处理策略

### 4.1 LR1冲突类型

- **移进-归约冲突**：当前状态下，既可以移进也可以归约
- **归约-归约冲突**：当前状态下，可以使用多个产生式进行归约

### 4.2 冲突解决方法

- **配置文件配置**：通过配置文件指定冲突处理策略
- **优先移进策略**：当遇到移进-归约冲突时，优先选择移进
- **优先归约策略**：当遇到移进-归约冲突时，优先选择归约
- **优先移进终结符**：对于特定终结符，优先选择移进

```cpp
// 冲突处理示例
if (act.contains('|')) {
    auto parts = act.split('|');
    QString policy = ConfigConstants::lr1ConflictPolicy().trimmed().toLower();
    auto prefer = ConfigConstants::lr1PreferShiftTokens();
    QString nextTok = a;
    
    // 根据配置选择动作
    if (policy == "prefer_shift") {
        // 优先选择移进动作
    } else if (policy == "prefer_reduce") {
        // 优先选择归约动作
    }
}
```

## 5. 测试与验证

### 5.1 测试用例

使用Tiny语言的语法规则作为测试用例：

```
program -> block.
block -> declarations statements
declarations -> declaration declarations | ε
declaration -> var identifierlist : type ;
identifierlist -> identifier , identifierlist | identifier
statements -> statement statements | ε
statement -> assignstatement | ifstatement | whilestatement | readstatement | writestatement
assignstatement -> identifier := expression ;
ifstatement -> if condition then statements else statements end
whilestatement -> while condition do statements end
readstatement -> read identifier ;
writestatement -> write expression ;
condition -> expression = expression | expression < expression
```

### 5.2 测试结果

#### 5.2.1 LL(1)分析结果

- 非终结符数量：12
- 终结符数量：18
- 产生式数量：16
- 预测分析表大小：12×18=216
- 无冲突产生

#### 5.2.2 LR1分析结果

- 项目集数量：32
- 动作表条目数：187
- Goto表条目数：110
- 无冲突产生

## 6. 性能分析

- **时间复杂度**：
  - 文法解析：O(n)
  - FIRST/FOLLOW集计算：O(n^3)
  - LR1项目集构建：O(2^n)
  - 语法分析：O(n)

- **空间复杂度**：
  - 分析表：O(n^2)
  - 分析栈：O(n)

## 7. 应用场景

- 编译器前端语法分析
- 语法检查工具
- 代码编辑器自动补全
- 语法高亮
- 代码格式化

## 8. 改进方向

- 实现LALR(1)分析器，平衡表达能力和效率
- 优化LR1项目集构建算法，减少状态数
- 添加更多语法错误恢复策略
- 支持语法树可视化编辑
- 实现增量语法分析，提高开发效率